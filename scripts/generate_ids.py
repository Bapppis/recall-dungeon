# python .\scripts\generate_ids.py --fail-on-range-errors --fail-on-duplicates
#!/usr/bin/env python3
"""Generate a simple IDS markdown from JSON files under src/main/resources/data.

Usage:
  python scripts/generate_ids.py        # writes IDS_generated.md
  python scripts/generate_ids.py --apply  # overwrite IDS.md (use with caution)

Notes:
- The script expects each JSON to contain an integer "id" and a "name" field.
- Files missing an id or name are skipped with a warning.
- The script groups entries by the top-level subfolder (creatures, items, properties, etc.) and by file path.
"""
import json
from pathlib import Path
import argparse
import sys

ROOT = Path(__file__).resolve().parents[1]
DATA_DIR = ROOT / 'src' / 'main' / 'resources' / 'data'
IDS_OUT = ROOT / 'src' / 'main' / 'resources' / 'data' / 'IDS_generated.md'
IDS_MD = ROOT / 'src' / 'main' / 'resources' / 'data' / 'IDS.md'

parser = argparse.ArgumentParser()
parser.add_argument('--fail-on-duplicates', action='store_true', help='Exit non-zero if duplicate ids are found')
parser.add_argument('--fail-on-range-errors', action='store_true', help='Exit non-zero if any id is outside its expected category range')
args = parser.parse_args()

entries = []
for p in sorted(DATA_DIR.rglob('*.json')):
    rel = p.relative_to(DATA_DIR)
    try:
        obj = json.loads(p.read_text(encoding='utf-8'))
    except Exception as e:
        print(f'Skipping {rel}: invalid json ({e})')
        continue
    idv = obj.get('id')
    name = obj.get('name')
    if idv is None or name is None:
        print(f'Skipping {rel}: missing id or name')
        continue
    entries.append((int(idv), name, str(rel).replace('\\', '/')))

# Define expected numeric ranges for specific folder prefixes. Each key is a tuple
# of path segments (relative to data/) and the rule matches when a file's path
# begins with that tuple. Values are (min_inclusive, max_inclusive, description).
# Add more rules here as needed.
RANGE_RULES = [
    (("items", "armor", "armor"), (7000, 7249, "Armor (7000-7249)")),
    # Example broader rule (kept for reference):
    # (("items", "armor"), (7000, 7999, "Armor (7000-7999)")),
]

# Sort by id
entries.sort()

# Group by top-level folder under data
from collections import defaultdict
groups = defaultdict(list)
by_id = defaultdict(list)
for idv, name, path in entries:
    top = Path(path).parts[0] if Path(path).parts else 'root'
    groups[top].append((idv, name, path))
    by_id[idv].append((name, path))

# Range validation
range_violations = []
for idv, name, path in entries:
    path_parts = Path(path).parts
    for key_parts, (minmax_min, minmax_max, desc) in [(k, v) for k, v in RANGE_RULES]:
        # key_parts is a tuple like ("items","armor","armor")
        kp = tuple(key_parts)
        if len(path_parts) >= len(kp) and tuple(path_parts[:len(kp)]) == kp:
            if not (minmax_min <= idv <= minmax_max):
                range_violations.append((idv, name, path, desc, minmax_min, minmax_max))
            break

lines = []
lines.append('# Auto-generated Asset ID Index')
lines.append('')
lines.append('This file was generated by scripts/generate_ids.py')
lines.append('')
for top in sorted(groups.keys()):
    lines.append(f'## {top}')
    lines.append('')
    for idv, name, path in groups[top]:
        lines.append(f'- {idv} — {name} — data/{path}')
    lines.append('')

content = '\n'.join(lines) + '\n'
IDS_OUT.write_text(content, encoding='utf-8')
print(f'Wrote {IDS_OUT}')

# Duplicate detection
dupes = {idv: entries for idv, entries in by_id.items() if len(entries) > 1}
if dupes:
    print('\nDetected duplicate IDs:')
    for idv in sorted(dupes.keys()):
        print(f'ID {idv} appears in:')
        for name, path in dupes[idv]:
            print(f'  - {name} -> data/{path}')
    print('')
    if args.fail_on_duplicates:
        print('Exiting with error due to --fail-on-duplicates')
        sys.exit(2)

# Range violation reporting
if range_violations:
    print('\nDetected ID range violations:')
    for idv, name, path, desc, mn, mx in range_violations:
        print(f'ID {idv} for "{name}" at data/{path} is outside expected range {mn}-{mx} ({desc})')
    print('')
    if args.fail_on_range_errors:
        print('Exiting with error due to --fail-on-range-errors')
        sys.exit(4)

# Note: writing to the canonical IDS.md is intentionally disabled in this
# simplified mode. The script only produces IDS_generated.md. If you need to
# overwrite IDS.md, use a separate manual step or re-enable the previous
# functionality.
