# python .\scripts\generate_ids.py --fail-on-range-errors --fail-on-duplicates
#!/usr/bin/env python3
"""Generate a simple IDS markdown from JSON files under src/main/resources/data.

Usage:
  python scripts/generate_ids.py        # writes IDS_generated.md
  python scripts/generate_ids.py --apply  # overwrite IDS.md (use with caution)

Notes:
- The script expects each JSON to contain an integer "id" and a "name" field.
- Files missing an id or name are skipped with a warning.
- The script groups entries by the top-level subfolder (creatures, items, properties, etc.) and by file path.
"""
import json
from pathlib import Path
import argparse
import sys

ROOT = Path(__file__).resolve().parents[1]
DATA_DIR = ROOT / 'src' / 'main' / 'resources' / 'data'
IDS_OUT = ROOT / 'src' / 'main' / 'resources' / 'data' / 'IDS_generated.md'
IDS_MD = ROOT / 'src' / 'main' / 'resources' / 'data' / 'IDS.md'

parser = argparse.ArgumentParser()
parser.add_argument('--fail-on-duplicates', action='store_true', help='Exit non-zero if duplicate ids are found')
parser.add_argument('--fail-on-range-errors', action='store_true', help='Exit non-zero if any id is outside its expected category range')
args = parser.parse_args()

entries = []
for p in sorted(DATA_DIR.rglob('*.json')):
    rel = p.relative_to(DATA_DIR)
    try:
        obj = json.loads(p.read_text(encoding='utf-8'))
    except Exception as e:
        print(f'Skipping {rel}: invalid json ({e})')
        continue
    idv = obj.get('id')
    name = obj.get('name')
    if idv is None or name is None:
        print(f'Skipping {rel}: missing id or name')
        continue
    entries.append((int(idv), name, str(rel).replace('\\', '/')))

# Define expected numeric ranges for specific folder prefixes. Each key is a tuple
# of path segments (relative to data/) and the rule matches when a file's path
# begins with that tuple. Values are (min_inclusive, max_inclusive, description).
# Updated to match IDS.md
RANGE_RULES = [
    (("items", "armor", "armor"), (20000, 21999, "Chest Armor (20000-21999)")),
    (("items", "armor", "helmets"), (22000, 23999, "Helmets (22000-23999)")),
    (("items", "armor", "legwear"), (24000, 25999, "Legwear (24000-25999)")),
    (("items", "armor", "shields"), (26000, 27999, "Shields (26000-27999)")),
    (("items", "consumables"), (28000, 28999, "Consumables (28000-28999)")),
    (("items", "weapons", "melee weapons", "slash weapons"), (29000, 30332, "Melee Slash Weapons (29000-30332)")),
    (("items", "weapons", "melee weapons", "piercing weapons"), (30333, 31665, "Melee Piercing Weapons (30333-31665)")),
    (("items", "weapons", "melee weapons", "blunt weapons"), (31666, 32999, "Melee Blunt Weapons (31666-32999)")),
    (("items", "weapons", "ranged weapons", "bows"), (34000, 35499, "Ranged Bows (34000-35499)")),
    (("items", "weapons", "ranged weapons", "crossbows"), (35500, 36999, "Ranged Crossbows (35500-36999)")),
    (("items", "weapons", "magic weapons", "staffs"), (37000, 37999, "Magic Staffs (37000-37999)")),
    (("items", "weapons", "magic weapons", "arcane"), (38000, 38999, "Magic Arcane (38000-38999)")),
    (("items", "weapons", "magic weapons", "magic physical"), (39000, 39999, "Magic Physical (39000-39999)")),
    (("properties", "buff"), (1000, 2332, "Buffs (1000-2332)")),
    (("properties", "debuff"), (2333, 3665, "Debuffs (2333-3665)")),
    (("properties", "trait"), (3666, 4999, "Traits (3666-4999)")),
    (("creatures", "players"), (5000, 5499, "Players (5000-5499)")),
    (("creatures", "neutrals"), (5500, 5999, "Neutrals (5500-5999)")),
    (("creatures", "beasts"), (7000, 7999, "Beasts (7000-7999)")),
    (("creatures", "constructs"), (9000, 9999, "Constructs (9000-9999)")),
    (("creatures", "undead"), (19000, 19999, "Undead (19000-19999)")),
    (("loot_pools",), (40000, 40999, "Loot Pools (40000-40999)")),
    (("monster_pools",), (41000, 41999, "Monster Pools (41000-41999)")),
    (("reserved",), (42000, 49999, "Reserved (42000-49999)")),
]

# Sort by id
entries.sort()

# Group by top-level folder under data
from collections import defaultdict
groups = defaultdict(list)
by_id = defaultdict(list)
for idv, name, path in entries:
    top = Path(path).parts[0] if Path(path).parts else 'root'
    groups[top].append((idv, name, path))
    by_id[idv].append((name, path))

# Range validation
range_violations = []
for idv, name, path in entries:
    path_parts = Path(path).parts
    for key_parts, (minmax_min, minmax_max, desc) in [(k, v) for k, v in RANGE_RULES]:
        # key_parts is a tuple like ("items","armor","armor")
        kp = tuple(key_parts)
        if len(path_parts) >= len(kp) and tuple(path_parts[:len(kp)]) == kp:
            if not (minmax_min <= idv <= minmax_max):
                range_violations.append((idv, name, path, desc, minmax_min, minmax_max))
            break

lines = []
lines.append('# Auto-generated Asset ID Index')
lines.append('')
lines.append('This file was generated by scripts/generate_ids.py')
lines.append('')
for top in sorted(groups.keys()):
    lines.append(f'## {top}')
    lines.append('')
    for idv, name, path in groups[top]:
        lines.append(f'- {idv} — {name} — data/{path}')
    lines.append('')

content = '\n'.join(lines) + '\n'
IDS_OUT.write_text(content, encoding='utf-8')
print(f'Wrote {IDS_OUT}')

# Duplicate detection
dupes = {idv: entries for idv, entries in by_id.items() if len(entries) > 1}
if dupes:
    print('\nDetected duplicate IDs:')
    for idv in sorted(dupes.keys()):
        print(f'ID {idv} appears in:')
        for name, path in dupes[idv]:
            print(f'  - {name} -> data/{path}')
    print('')
    if args.fail_on_duplicates:
        print('Exiting with error due to --fail-on-duplicates')
        sys.exit(2)

# Range violation reporting
if range_violations:
    print('\nDetected ID range violations:')
    for idv, name, path, desc, mn, mx in range_violations:
        print(f'ID {idv} for "{name}" at data/{path} is outside expected range {mn}-{mx} ({desc})')
    print('')
    if args.fail_on_range_errors:
        print('Exiting with error due to --fail-on-range-errors')
        sys.exit(4)

# Note: writing to the canonical IDS.md is intentionally disabled in this
# simplified mode. The script only produces IDS_generated.md. If you need to
# overwrite IDS.md, use a separate manual step or re-enable the previous
# functionality.
